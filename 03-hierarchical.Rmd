# Hierarchical structure {#hierarchical}

There are two parts to simulating hierarchical data. First you need to have a hierarchical data structure and second you need parameters at each of the different hierarchical levels. The data structure is essentially a data.frame (or matrix), with all the grouping factors and their levels, as we would see in a typical dataset. In this Section, we will first demonstrate how to make a hierarchical structure using the `make_structure` function. `simulate_population` also allows pre-existing data structures to be incorporated. The remaining part of the section details how to simulate hierarchical data once you have a hierarchical data structure. 



## Making a hierarchical structure {#makestr}

We can use the `make_structure` function to create nested and crossed hierarchical data structures. The `make_structure` function only produces balanced data structures, but these can be made unbalanced using by sampling, which is outlined in Section \@ref(sampling)

```{r, echo=FALSE, message=FALSE,warning=FALSE}
plot_nested<-function(data_structure){
  par(mar=c(0,10,1,1))
  plot(NA, xlim=c(1,nrow(data_structure)), ylim=c(ncol(data_structure)+0.5,0.5), yaxt="n", ylab="",bty="n", xlab="", xaxt="n")
  axis(2,1:ncol(data_structure),colnames(data_structure), lty=0, las=2)
  for(i in 1:ncol(data_structure)){
    x<-data_structure[,i]
    line_coords <- sapply(1:max(x), function(j) range(which(x==j)))
    arrows(line_coords[1,],i,line_coords[2,],i, code=0, col=c(1,2))
    text(x=colMeans(line_coords),y=i-0.1,1:ncol(line_coords), cex=0.5)
  }
}
```

### Single Factor

Simplest structure - one grouping factor with multiple observations. Here we create a structure with 2 repeated observations of 5 individuals (small number are used here simply for illustration purposes). The `structure` contains the name of the grouping factors and their sample sizes, and `repeat_obs` is the number of repeated observations.
```{r}
make_structure(structure="individual(5)", repeat_obs=2)
```


### Nested factors
If we want to have nested factors, so different hierarchical groups, where levels of one group only exist in one higher group then we can use the `/` symbol in the `structure` argument. For example, here we have 2 sexes, each with 5 individuals, with 2 repeated measurements each. 
```{r}
make_structure(structure="sex(2)/individual(5)", repeat_obs=2)
```
<!-- In this case we have created a nested structure with 2000 observations - 2 observations for each of 1000 individuals, 500 for each of 2 sexes. We can then use this to simulate variation at different levels. Note that sample sizes are extracted from the data structure and so we do not need to specify `N` in the `simulate_population` function as above.
 -->
```{r,fig.width=6,fig.height=1.2, echo=FALSE}
dat_str <- make_structure(structure="sex(2)/individual(5)", repeat_obs=2)
plot_nested(dat_str)
```
Note that in the nesting, the sample size for the lower group now represents the number within each level of the higher, rather than the total sample size, so overall there is 10 individuals. 

We can nest as much as we want:
```{r}
make_structure(structure="species(2)/population(2)/individual(2)", repeat_obs=2)
```

```{r,fig.width=6,fig.height=1.8, echo=FALSE}
dat_str <- make_structure(structure="species(2)/population(2)/individual(2)", repeat_obs=2)
plot_nested(dat_str)
```


### Crossed factors
We can create completely crossed factors - every combination of levels exists - using the `+` symbol in the `structure` argument
```{r}
make_structure(structure="treatment(2) + individual(5)", repeat_obs=1)

```

We can combine crossed and nested structures:
```{r}
make_structure(structure="treatment(2) + sex(2)/individual(5)", repeat_obs=1)
```

We can also output the crossed and nested using `:`
```{r}
make_structure(structure="treatment(2) + individual(5) + treatment:individual", repeat_obs=1)
```


### Temporal structure
```{r}
make_structure(structure="year(2)/month(12)/day(30)", repeat_obs=1)
```

```{r}
make_structure(structure="year(2) + month(12) + day(30) + year:month:day", repeat_obs=1)
```

<!-- ```{r}
dat_str <- make_structure(structure="species5(2)/population(2)/individual(10)", repeat_obs=3)

plot_nested(dat_str)

structure="species(2)/population5(2)/individual(10)"
structure <- gsub("\\s","",structure)
gsub(".\\)(.)","\\1",structure)
strsplit((gsub("\\w+\\(\\d+\\)","",structure)),"")[[1]]



```
 -->





## Simulating data at different hierarchical levels
<!-- <div class="panel panel-success">
<div class="panel-heading">
**Biological example**
</div>
<div class="panel-body">
We have taken repeated measurements of adult body mass.  
</div>
</div> -->

We can simulate predictors at different hierarchical levels. Lets take the example of a situation where we have repeated measures of individuals. The individuals have traits that are consistently expressed, whilst the environment varies between observations. We can describe variation at these different hierarchical levels as:

<div class="alert alert-info">

$$
y = \beta_0 + \boldsymbol Z_j \boldsymbol\beta_z + \boldsymbol X_i \boldsymbol\beta_x + \epsilon_{i,j}
$$
$$
\boldsymbol X \sim MVN(\mu_x,\Sigma_x)
$$
$$
\boldsymbol Z \sim MVN(\mu_z,\Sigma_z)
$$
$$
\epsilon \sim N(0,\sigma^2_\epsilon)
$$
</div>

where $Z$ is a matrix of predictors at the individual level, and $X$ is a matrix of predictors at the observation level.

In order to simulate from this model, we need a data structure and parameters for each of these levels. 
To do this, we can either specify a data structure generated using `make_structure` (outlined in the previous section \@ref(makestr)), or a pre-existing data structure, to the `simulate_population` function. We then add in a item to the parameter list, the name of which matches on of the grouping factors in the data structure, and specify the parameters for predictors that vary at that level in the same way as outlined in the previous section (\@ref(linearmod)).

```{r}
squid_data <- simulate_population(
  data_structure = make_structure(structure = "individual(500)", repeat_obs=2),
  parameters = list(
    individual = list(
      names = c("size","behaviour","physiology"),
      beta = c(0.1,0.3,0.2)
    ),
    observation = list(
      names=c("temperature","rainfall"),
      beta = c(0.2,-0.1)
    ),
    residual = list(
      vcov = 0.5
    )
  )
)

data <- get_population_data(squid_data)

coef(lm(y ~ size + behaviour + physiology + temperature + rainfall , data))

```

Here, we have simulated 5 predictors, 'size', 'behaviour' and 'physiology' that vary at the level of the individual, and 'temperature' and 'rainfall' that vary at the level of the observation (all with mean=0 and variance=1). Note, the names of the different grouping factors in the parameter list need to exactly match those in the data structure. The order does not, however, have to be the same. There are circumstances in which we may want to simulate two sets of effects at the same hierarchical level (for example see permanent environment effects in Section \@ref(va)), in this case we can call them different things in the parameter list, but link them back to the grouping factor, by providing a `group` name. For example the following will produce the same simulation as above:

```{r}
squid_data <- simulate_population(
  data_structure = make_structure(structure = "individual(500)", repeat_obs=2),
  parameters = list(
    ind1 = list(
      group="individual",
      names = c("size"),
      beta = c(0.1)
    ),
    ind2 = list(
      group="individual",
      names = c("behaviour","physiology"),
      beta = c(0.3,0.2)
    ),
    observation = list(
      names=c("temperature","rainfall"),
      beta = c(0.2,-0.1)
    ),
    residual = list(
      vcov = 0.5
    )
  )
)
```


It is also worth noting that predictors do not have to be simulated for every grouping factor in the data structure.

### Simulating 'random effects'

<!-- I would replace “this is simulating “ to something more explicit, like “In essence, running mixed models requires to simulate datasets with repeated values for individuals. This can be done by simulating a single combined predictor at each level…” -->
In essence, random effects (random intercepts) are an unobserved/latent predictor (or group of predictors), which varies at a given hierarchical level. In a mixed effect model, the effect at each level of the grouping factor is unknown, and estimated by the model (and assumed to come from a normal distribution). When simulating this, however, we can simply simulate an additional predictor at a particular level ($z$) with mean 0 and a given variance ($\sigma^2_z$). 

<div class="alert alert-info">

$$
y_{i,j} = \beta_0 + z_j + \epsilon_{i,j}
$$
$$
z \sim N(0,\sigma^2_z)
$$
$$
\epsilon \sim N(0,\sigma^2_\epsilon)
$$
</div>

For example we can simulate some between-individual variation as follows:

```{r}
squid_data <- simulate_population(
  data_structure = make_structure(structure = "individual(500)", repeat_obs=2),
  parameters = list(
    individual = list(
      vcov = 0.5
    ),
    residual = list(
      vcov = 0.5
    )
  )
)

data <- get_population_data(squid_data)
head(data)

library(lme4)
short_summary <- function(x) print(summary(x), correlation=FALSE, show.resids=FALSE, ranef.comp = c("Variance"))

short_summary(lmer(y ~ 1 + (1|individual), data))
```

Note that here we haven't specified any variable names. In this case the simulated predictors are named by the grouping factors (e.g. individual_effects).

### Incorporating existing data structures

We could also use an existing data structure, taking the grouping factors and levels from an existing dataset and input them to `simulate_population`. To demonstrate this, we can use the [blue tit dataset](https://rdrr.io/cran/MCMCglmm/man/BTdata.html) provided with the MCMCglmm package. This is a dataset with some continuous variables (tarsus, back (coloration) and hatchdate), and some grouping factors (animal, dam, fosternest and sex), the latter providing a data structure from which to simulate.

```{r}
library(MCMCglmm)
data(BTdata)
head(BTdata)

squid_data <- simulate_population(
  data_structure = BTdata[,c("dam","fosternest")],
  parameters = list(
    dam = list(
      vcov = 0.2
    ),
    fosternest = list(
      vcov = 0.3
    ),
    residual = list(
      vcov = 0.5
    )
  )
)

data <- get_population_data(squid_data)
data

```


<!-- The importing a real dataset is very cool! But, I think there needs to be more explanation. How does this work when dam, fosternest, and residual lists are empty of variable names? Can you use the variances in the data instead of specifying them?
 -->
<!-- getME(mod,"theta")
library(numDeriv)
fm1Fun <- update(mod,devFunOnly=TRUE)
fm1_thpar <- getME(mod,"theta")
h <- hessian(fm1Fun, fm1_thpar)
sqrt(diag(solve(h)))

mySumm2 <- function(.) {
    c(beta=fixef(.),sigma=sigma(.), sig01=unlist(VarCorr(.)))
}
bootMer(mod,mySumm2,nsim = 100) -->

<!-- This setup also allows us to create variation at each level that is driven by specific predictors -->
<!-- 
Dave: At the bit just before Fixed Factors, what do you mean by “This setup”? It implies the data file import action in the previous section, which makes no sense. 
Anne: the sentence “This setup also allows us to create variation at each level that is driven by specific predictors” comes out of the blue, and I find the wording ‘this setup’ too unspecific.

-->




## Factors
So far the simulated predictors have all been continuous, but we may want to simulate factors with known or *fixed* effects i.e. not drawn from a normal distribution. In this case we can specify `fixed = TRUE` for a particular level, and then give a beta for all the different levels of that group.


Lets take the example of sex. Factors can be thought of as a hierarcihc First we can create a data structure using the 

```{r,fig.width=6,fig.height=6}
squid_data <- simulate_population(
  data_structure = make_structure(structure = "sex(2)/individual(500)", repeat_obs=2),
  parameters = list(
    sex=list(
      fixed=TRUE,
      names=c("female","male"),
      beta=c(-0.5,0.5)
    ),
    residual = list(
      vcov = 0.5
    )
  )
)

data <- get_population_data(squid_data)

boxplot( y ~ factor(sex), data)
lm( y ~ factor(sex), data)
```


### Fixed Factor Interactions

```{r,fig.width=6,fig.height=6}
squid_data <- simulate_population(
  data_structure = make_structure(structure = "sex(2)/individual(500)", repeat_obs=2),
  parameters = list(
    sex=list(
      fixed=TRUE,
      names=c("female","male"),
      beta=c(-0.5,0.5)
    ),
    observation= list(
      names = c("environment"),
      beta =c(0.2)
      ),
    interactions = list(
      names=c("environment:male"),
      beta = 0.2
      ),
    residual = list(
      names="residual",
      vcov = 0.1
    )
  )
)

data <- get_population_data(squid_data)
head(data)
plot(y~environment,data, pch=19, col=alpha(c(1,2),0.5)[factor(data$sex)])

lm( y ~ 0 + factor(sex)*environment, data)
```


## Random slopes {#randomslopes}

Random slopes are essentially an interaction between predictors at different levels, with the random slopes being an unobserved, latent variable.

<div class="alert alert-info">

$$
y_{i,j} = \beta_0 + \beta_1 x_{i,j} + z_{1,j} + z_{2,j}x_{i,j}  + \epsilon_{i,j}
$$
$$
Z \sim MVN(0,\Sigma_{z})
$$
$$
\epsilon \sim N(0,\sigma^2_\epsilon)
$$

</div>

We can specify random slopes by simulating a slopes variable at the individual level (`ind_slope` - $z_{2,j}$). We can specify the mean environmental effect the slope of the environmental variable ($beta_1$). $z_{2,j}$ then represents the deviations from the mean slope (this is typically how it is modelling in a linear mixed effect model).
<!-- alternatively the mean environmental effect could be specified as the mean of the slopes variable with the environment slope as 0 -->
Importantly the `beta` parameter associated with `ind_slope` is specified as 0 (there is no 'main effect' of the slopes, just the interaction), and the `beta` parameter associated with interaction is 1.


```{r}

squid_data <- simulate_population(
  data_structure=make_structure("individual(300)",repeat_obs=10),
  parameters = list(
    individual = list(
      names = c("ind_int","ind_slope"), 
      beta = c(1,0),
      vcov = matrix(c(1,0.3,0.3,0.5),ncol=2,nrow=2)
    ),
    observation= list(
      names = c("environment"),
      beta = c(0.2)
    ), 
    residual = list(
      vcov = c(0.5)
    ),
    interactions = list(
      names = c("ind_slope:environment"),
      beta = c(1)
    )
  )
)

data <- get_population_data(squid_data)

short_summary(lmer(y ~ environment + (1+environment|individual),data))
```
